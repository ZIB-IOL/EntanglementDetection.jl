var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#EntanglementDetection.AlternatingSeparableLMO","page":"API reference","title":"EntanglementDetection.AlternatingSeparableLMO","text":"AlternatingSeparableLMO{T, N, MB <: AbstractMatrix{Complex{T}}} <: SeparableLMO{T, N}\n\nAlternatingSeparableLMO implements compute_extreme_point(lmo, direction) which returns a pure product state used in Frank-Wolfe algorithms. The method used is an alternating algorithm starting from random pure states on each party and alternatively optimizing each reduced state via an eigendecomposition.\n\nType parameters:\n\nT: element type of the correlation tensor\nN: number of parties\nMB: type of the matrix basis\n\nFields:\n\ndims: dimensions of the reduced state on each party\nmatrix_basis: matrix basis of the correlation tensor\nmax_iter: maximum number of alternation steps\nthreshold: threshold to stop the alternation\nnb: number of random rounds to find the possible global optimal\nworkspace: contains fields pre-allocated performance-critical functions\ntmp: temporary vector for fast scalar products of bipartite tensors\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection.CrossPolytopeSubdivision","page":"API reference","title":"EntanglementDetection.CrossPolytopeSubdivision","text":"CrossPolytopeSubdivision{T} <: ApproximationQuantumStates{T}\n\nApproximates the complex sphere in dimension d via an edgewise subdivision of the cross-polytope on the real sphere in dimension 2d-1.\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection.EnumeratingSeparableLMO","page":"API reference","title":"EntanglementDetection.EnumeratingSeparableLMO","text":"EnumeratingSeparableLMO{T, N, MB <: AbstractMatrix{Complex{T}}} <: SeparableLMO{T, N}\n\nEnumeratingSeparableLMO implements compute_extreme_point(lmo, direction) which returns a pure product state used in Frank-Wolfe algorithms. The method used is the enumeration of a fine approximation of the sets of states on all parties except the first one, for which an eigendecomposition suffices.\n\nType parameters:\n\nT: element type of the correlation tensor\nN: number of parties\nMB: type of the matrix basis\n\nFields:\n\ndims: dimensions of the reduced state on each party\nmatrix_basis: matrix basis of the correlation tensor\nworkspace: contains fields pre-allocated performance-critical functions\ntmp: temporary vector for fast scalar products of bipartite tensors\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection.KSeparableLMO","page":"API reference","title":"EntanglementDetection.KSeparableLMO","text":"KSeparableLMO{T, N, LMO} <: SeparableLMO{T, N}\n\nKSeparableLMO implements compute_extreme_point(lmo::LMO, direction) which returns a pure product state by considering all K-partite partitions by iterating over all LMO{T, K}.\n\nType parameters:\n\nT: element type of the correlation tensor\nN: number of parties\nMB: type of the matrix basis\nLMO: type of the LMO for k-partite separability\n\nFields:\n\ndims: dimensions of the reduced state on each party\nmatrix_basis: matrix basis of the correlation tensor\nlmos: list of LMOs for all K-partitions\npartitions: list of K-partite partitions\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection.PolytopePhasedComplexSphere","page":"API reference","title":"EntanglementDetection.PolytopePhasedComplexSphere","text":"PolytopePhasedComplexSphere{T} <: ApproximationQuantumStates{T}\n\nApproximates the complex sphere in dimension d via a polytope on the real sphere in dimension d and d-1 phases.\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection.PolytopeReducedComplexSphere","page":"API reference","title":"EntanglementDetection.PolytopeReducedComplexSphere","text":"PolytopeReducedComplexSphere{T} <: ApproximationQuantumStates{T}\n\nApproximates the complex sphere in dimension d via a polytope on the real sphere in dimension 2d-1.\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection.PureState","page":"API reference","title":"EntanglementDetection.PureState","text":"PureState{T, N} <: AbstractArray{T, N}\n\nRepresents a pure product state. Each subsystem is a pure state stored as a tensor PureState.tensors[n].\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection.Workspace","page":"API reference","title":"EntanglementDetection.Workspace","text":"Workspace{T, N}\n\nStructure for initial pre-allocation of performance-critical functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EntanglementDetection._correlation_tensor_ket!-Union{Tuple{MB}, Tuple{T}, Tuple{Vector{T}, AbstractArray{Complex{T}, 1}, Vector{MB}}} where {T<:Real, MB<:AbstractArray{Complex{T}, 2}}","page":"API reference","title":"EntanglementDetection._correlation_tensor_ket!","text":"_correlation_tensor_ket!(tensor::Vector{T}, φ::Vector{Complex{T}}, matrix_basis)\n\nConvert a ket φ to a correlation tensor Vector{T}, with same subspace dimension d.\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection._eigmin!-Tuple{Vector{ComplexF64}, Matrix{ComplexF64}, EntanglementDetection.BlasWorkspace{Float64}}","page":"API reference","title":"EntanglementDetection._eigmin!","text":"_eigmin!(ket::Vector, matrix::Matrix)\n\nComputes the minimal real eigenvalue and updates ket in place The variable matrix of size d × d also gets overwritten. For BLAS-compatible types, uses LAPACK.syev! for d ≤ 5 and LAPACK.syevr! otherwise. For other types, falls back to eigen!.\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection._reduced_tensor!-Union{Tuple{N}, Tuple{T}, Tuple{Vector{T}, NTuple{N, Vector{T}}, AbstractArray{T, N}, Int64}, Tuple{Vector{T}, NTuple{N, Vector{T}}, AbstractArray{T, N}, Int64, Vector{Int64}}} where {T<:Real, N}","page":"API reference","title":"EntanglementDetection._reduced_tensor!","text":"_reduced_tensor!(tensor::Vector{T}, pure_tensors::NTuple{N, Vector{T}}, dir::Array{T, N}, j::Int, s::Vector{Int} = setdiff(1:N, j)) where {T <: Real, N}\n\nComputes the correlation tensor of the j-th subsystem (the tensor-version of the partial trace). When N=2, j=1, computes ⟨ϕ2|dir|ϕ2⟩ for dir ∈ H₁ ⊗ H₂\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.correlation_tensor-Union{Tuple{N}, Tuple{CT}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}, Any}} where {CT<:Number, N}","page":"API reference","title":"EntanglementDetection.correlation_tensor","text":"correlation_tensor(ρ::Matrix{T}, dims::NTuple{N, Int})\n\nConvert a dimension-(a)symmetry density matrix ρ to a correlation tensor Array{T, N}, with subspace dimensions dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.density_matrix-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, NTuple{N, Int64}}, Tuple{AbstractArray{T, N}, NTuple{N, Int64}, Any}} where {T<:Real, N}","page":"API reference","title":"EntanglementDetection.density_matrix","text":"function density_matrix(tensor::Vector{T}, dims::NTuple{N,Int}, matrix_basis = _gellmann(T, dims)) where {T <: Real} where {N}\n\nConvert tensors of pure states to density matrix (for eigendecomposition).\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.entangled_bound_with_white_noise-Union{Tuple{N}, Tuple{CT}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}}} where {CT<:Number, N}","page":"API reference","title":"EntanglementDetection.entangled_bound_with_white_noise","text":"entangled_bound_with_white_noise(ρ::AbstractMatrix{CT}, dims::NTuple{N, Int}; atol = 1e-4) where {CT <: Number, N}\n\nGiven a quantum state ρ, using PPT criterion calculate the upper bound for the amount of white noise it can tolerate such that ρ = (1-p) * ρ + p * I/d is entangled. Note this is corresponding to the fully separability. Returns the upper bound p.\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.entanglement_detection-Union{Tuple{LMO}, Tuple{N}, Tuple{CT}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}, LMO}} where {CT<:Number, N, LMO<:EntanglementDetection.SeparableLMO}","page":"API reference","title":"EntanglementDetection.entanglement_detection","text":"entanglement_detection(ρ::AbstractMatrix{T}, dims::NTuple{N, Int}; measure, algorithm, kwargs...) where {T <: Number, N}\n\nGiven a quantum state ρ with subsystem dimensions as dims, make a judgment about whether it is entangled or separable. If the argument dims is omitted equally-sized subsystems are assumed, which is solving on the symmetry bipartite separable space.\n\nReturns a named tuple (ent, atoms, witness) with:\n\nent true/false/nothing, the judgment as entangled/separable/can't tell\nwitness the witness for the entangled ρ, nothing for separable ρ\ndecompose a tuple with weights and pure separable states, the best separable decomposition for separable ρ or for the closest separable state of entangled ρ\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.entanglement_robustness-Union{Tuple{N}, Tuple{T}, Tuple{Function, Array{Vector{T}}, NTuple{N, Int64}}} where {T<:Real, N}","page":"API reference","title":"EntanglementDetection.entanglement_robustness","text":"entanglement_robustness(ρ_p::Function, p_list::Array{Vector{T}}, dims::NTuple{N, Int}; monotone, robust_monitor, kwargs...)\n\nDecide the entanglement and separable regions for a family of quantum state ρ_p.\n\nInputs:\n\nρ_p the function for a family of quantum states\np_list the parameter region for ρ_p(p) \nmonotone the monotony of the function if with only one parameter (default: true)\nrobust_monitor the monitor for the calculation of the robustness problem\n\nReturns a named tuple (ent_range, nan_range, sep_range) with:\n\nent_range the parameter range for p such that ρ_p(p) is entangled.\nnan_range the parameter range for p such that ρ_p(p) can not be decided.\nsep_range the parameter range for p such that ρ_p(p) is separable.\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.entanglement_witness-Union{Tuple{N}, Tuple{CT}, Tuple{AbstractMatrix{CT}, AbstractMatrix{CT}, NTuple{N, Int64}}} where {CT<:Number, N}","page":"API reference","title":"EntanglementDetection.entanglement_witness","text":"entanglement_witness(ρ::AbstractMatrix, σ::AbstractMatrix; dims, kwargs...)\n\nGiven a direction from a state σ in the separable space to a entangled state ρ, find the best witness that detect the entanglement of the state along this direction:\n\nW = (σ-ρ + Tr[σ(ρ-σ)]*I)/||ρ-σ||\n\nwhich satisfies ∀σ ∈ SEP, Tr(Wσ) ≥ 0, and ∃ρ, Tr(Wρ) < 0.\n\nReturns a named tuple (W, α, ε, σ, ϕ) with:\n\nW the witness operator\nα = Tr[ϕ(ρ-σ)]/||ρ-σ||, the overlap\nε the ε-net, normalized by ||ρ-σ||\nβ = Tr[σ(ρ-σ)]/||ρ-σ||, the overlap\nσ decide the direction from σ to ρ\nϕ the closest pure separable state\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.entanglement_witness-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix{T}, NTuple{N, Int64}}} where {T<:Number, N}","page":"API reference","title":"EntanglementDetection.entanglement_witness","text":"entanglement_witness(ρ::AbstractMatrix{T}; dims, kwargs...)\n\nGiven a quantum state ρ, find the best witness that detect the entanglement of the state, defined by\n\nW = (σ-ρ + Tr[σ(ρ-σ)]*I)/||ρ-σ||\n\nwhich satisfies ∀σ ∈ SEP, Tr(Wσ) ≥ 0, and ∃ρ, Tr(Wρ) < 0.\n\nReturns a tuple (W, σ, α) with:\n\nW the witness operator\nσ the closest pure separable state\nα = Tr[σ(ρ-σ)], the overlap\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.separable_ball_criterion-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, NTuple{N, Int64}}} where {T<:Number, N}","page":"API reference","title":"EntanglementDetection.separable_ball_criterion","text":"separable_ball_criterion(ρ, σ, dims; kwargs...)\n\nGiven a quantum state ρ and a separable state σ, define a quantum state\n\nρ' = (1+t)/t * ρ - 1/t * σ, s.t. ρ = t/(1-t) * ρ' + 1/(1-t) * σ.\n\nBy confirming ρ' inside a separable ball to confirm the separability of ρ.\n\nReturns a named tuple (sep, atoms, witness) with:\n\nsep true/false, the judgment of separability\np = t/(1-t), the weight for ρ'\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.separable_ball_criterion-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix{T}, NTuple{N, Int64}}} where {T<:Number, N}","page":"API reference","title":"EntanglementDetection.separable_ball_criterion","text":"separable_ball_criterion(ρ, dims; kwargs...)\n\nGiven a quantum state ρ with subsystem dimensions as dims, define a quantum state\n\nρ' = (1+t)/t * ρ - 1/t * σ, s.t. ρ = t/(1-t) * ρ' + 1/(1-t) * σ.\n\nwhere σ is the closest separable pure state. By confirming ρ' inside a separable ball to confirm the separability of ρ.\n\nReturns a named tuple (sep, atoms, witness) with:\n\nsep true/false, the judgment of separability\np = t/(1-t), the weight for ρ'\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.separable_ball_membership-Union{Tuple{N}, Tuple{T}, Tuple{AbstractMatrix{T}, NTuple{N, Int64}}} where {T<:Number, N}","page":"API reference","title":"EntanglementDetection.separable_ball_membership","text":"separable_ball_membership(ρ::AbstractMatrix{T}, dims::NTuple{N, Int}; kwargs...)\n\nJudges whether a given quantum state ρ in a separable ball with subsystem dimensions as dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.separable_ball_radius-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, NTuple{N, Int64}}} where {T<:Number, N}","page":"API reference","title":"EntanglementDetection.separable_ball_radius","text":"separable_ball_radius(::Type{T}, dims::NTuple{N, Int})\n\nLower bound of the radius of a separable ball, centered around the maximally mixed state.\n\nReference:\n\nN-qubits\nN-qudits\ngeneral case\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.separable_bound_with_white_noise-Union{Tuple{N}, Tuple{T}, Tuple{NTuple{N, Int64}, T, T}} where {T<:Real, N}","page":"API reference","title":"EntanglementDetection.separable_bound_with_white_noise","text":"separable_bound_with_white_noise(::Type{T}, dims::NTuple{N, Int}, ent_bound::T, distance::T) where {T <: Real, N}\n\nConsider a quantum state mixed with white noise as ρ(p) = (1-p) * ρ + p * I/d for the separability problem. \n\nGiven\n\ndims for the structure of the separable space\nent_bound the noise level such that ρ(ent_bound) could be entangled (not necessary)\ndistance = min{σ ∈ SEP}||ρ(`entbound`) - σ||, the distance between the state and the separable space\n\nReturn the noise level such that ρ(sep_bound) must be separable.\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.separable_distance-Union{Tuple{LMO}, Tuple{N}, Tuple{CT}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}, LMO}} where {CT<:Number, N, LMO<:EntanglementDetection.SeparableLMO}","page":"API reference","title":"EntanglementDetection.separable_distance","text":"separable_distance(ρ::AbstractMatrix{CT}; dims, measure, fw_algorithm, kwargs...)\nseparable_distance(C::Array{T, N}; matrix_basis, measure, fw_algorithm, kwargs...)\n\nComputes the distance between the quantum density matrix ρ and the separable space under a specific measure via a specific fw_algorithm:\n\nf(ρ) = min_{σ ∈ SEP} g(ρ,σ)\n\nFor the density matrix ρ, if the argument dims is omitted equally-sized subsystems are assumed, which is solving on the symmetry bipartite separable space. For the correlation tensor C, if the argument matrix_basis is omitted, Gell-Mann matrix is assumed, which is Pauli basis for qubit systems.\n\nThe quantum state can also be given by a correlation tensor C corresponding to the experimental data from a set of (over-)completed matrix_basis. If the argument matrix_basis is omitted the generalized Gell-Mann basis are assumed.\n\nThe measure g(ρ,σ) can be set as\n\n\"2-norm\",\n\"relative-entropy\",\nsquared \"Bures metric\".\n\nThe fw_algorithm can be used as\n\nFrankWolfe.frank_wolfe\nFrankWolfe.lazified_conditional_gradient\nFrankWolfe.away_frank_wolfe\nFrankWolfe.blended_pairwise_conditional_gradient\n\nReturns a named tuple (σ, v, primal) with:\n\nσ the closest density matrix in the separable space\nv the closest pure separable state ket on the boundary of the separable space\nprimal primal value f(x), the distance to the separable space\nactive_set all the pure separable states, which combined to the closest separable state σ\nlmo the structure for related computation\n\n\n\n\n\n","category":"method"},{"location":"api/#EntanglementDetection.white_noise_robustness-Union{Tuple{LMO}, Tuple{N}, Tuple{CT}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}}, Tuple{AbstractMatrix{CT}, NTuple{N, Int64}, LMO}} where {CT<:Number, N, LMO<:EntanglementDetection.SeparableLMO}","page":"API reference","title":"EntanglementDetection.white_noise_robustness","text":"function whitenoiserobustness(ρ::AbstractMatrix{CT}, dims::NTuple{N, Int}, lmo::LMO; entproof, sepsearch, noise_atol, kwargs...) where {CT <: Number, N, LMO <: SeparableLMO}\n\nGiven a quantum state ρ, calculate the upper and lower bounds for the amount of white noise it can tolerate to be separable.\n\nent_proof: true/false use the enumerate method to guarantee the entanglement\nsep_search: true/false use the linear search method to find a possible better separable bound\nnoise_atol: the numerical accuracy for the noise level\n\nReturns a tuple (ent_bound, sep_bound).\n\n\n\n\n\n","category":"method"},{"location":"#EntanglementDetection","page":"Home","title":"EntanglementDetection","text":"","category":"section"}]
}
